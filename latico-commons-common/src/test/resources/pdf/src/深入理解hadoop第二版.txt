目录
译者序
作者简介
前言
第1章为什么会有大数据1
1.1什么是大数据1
1.2大数据技术背后的核心思想2
1.2.1把数据分发到多个节点2
1.2.2把计算逻辑移动到数据附近3
1.2.3计算节点进行本地数据处理3
1.2.4优选顺序读，次之随机读4
1.2.5一个例子4
1.3大数据的编程模型5
1.3.1大规模并行处理数据库系统5
1.3.2内存数据库系统6
1.3.3MapReduce系统6
1.3.4整体同步并行系统8
1.4大数据和事务性系统8
1.5我们能处理多大的数据量9
1.5.1一个计算密集型的例子10
1.5.2Amdhal定律10
1.6大数据商业用例11
1.7本章小结12
第2章Hadoop中的概念13
2.1Hadoop简介13
2.2MapReduce编程模型简介15
2.3Hadoop系统的组成19
2.3.1Hadoop 分布式文件系统20
2.3.2辅助名称节点25
2.3.3任务跟踪器26
2.3.4作业跟踪器26
2.4Hadoop 2.027
2.4.1容器29
2.4.2节点管理器29
2.4.3资源管理器30
2.4.4应用程序管理器30
2.4.5分步详解YARN请求31
2.5HDFS 的高可用性33
2.6本章小结33
第3章初识Hadoop框架34
3.1安装类型34
3.1.1单机模式35
3.1.2伪分布式集群模式35
3.1.3多节点集群安装模式35
3.1.4基于Amazon EMR预安装模式35
3.2使用Cloudera虚拟机搭建开发环境36
3.3一个MapReduce程序的组成37
3.4第一个Hadoop程序38
3.4.1以本地模式运行程序的必要条件39
3.4.2使用旧API编写的单词计数程序39
3.4.3构建程序42
3.4.4在集群模式下运行单词计数程序42
3.4.5使用新API编写的单词计数程序43
3.4.6构建程序44
3.4.7在集群模式下运行单词计数程序45
3.5Hadoop作业中的第三方函数库45
3.6本章小结50
第4章Hadoop系统管理51
4.1Hadoop的配置文件51
4.2配置Hadoop守护进程52
4.3Hadoop配置文件的优先级53
4.4深入探究Hadoop配置文件54
4.4.1core—site.xml54
4.4.2hdfs—*.xml55
4.4.3mapred—site.xml56
4.4.4yarn—site.xml58
4.4.5YARN中的内存分配60
4.5调度器61
4.5.1计算能力调度器62
4.5.2公平调度器65
4.5.3公平调度器配置65
4.5.4 yarn—site.xml 配置66
4.5.5策略文件的格式和配置67
4.5.6按照drf策略来确定优势资源的分配68
4.6从属文件69
4.7机架感知69
4.8 集群管理工具71
4.8.1检查HDFS71
4.8.2 HDFS管理命令行73
4.8.3 均衡HDFS上的数据分布75
4.8.4从HDFS中复制海量数据76
4.9本章小结76
第5章MapReduce开发基础78
5.1 Hadoop和数据处理78
5.2 航空公司数据集介绍79
5.2.1 准备开发环境80
5.2.2 准备Hadoop系统81
5.3 MapReduce编程模式81
5.3.1 只有Map阶段的作业（SELECT和WHERE查询）82
5.3.2 问题定义—SELECT子句82
5.3.3 问题定义—WHERE子句90
5.3.4 Map和Reduce作业（聚合查询）93
5.3.5 问题定义—GROUP BY和SUM子句93
5.3.6 应用Combiner提高Aggregation性能99
5.3.7 问题定义—优化后的Aggregators99
5.3.8 Partitioner的作用104
5.3.9 问题定义—按月分离航空数据105
5.4 综合分析108
5.5 本章小结110
第6章MapReduce开发进阶111
6.1 MapReduce编程模式111
6.2 Hadoop I／O 介绍111
6.3 问题定义—排序114
6.3.1 主要挑战：全排序115
6.3.2 在Cluster中运行Sorting作业125
6.3.3 仅根据Writable键排序125
6.3.4 根据排序回顾Hadoop的关键特性128
6.4 问题定义—分析连续的记录128
6.4.1 支持二次排序的重要组件129
6.4.2 在没有Grouping Comparator的情况下实现Secondary Sort136
6.4.3 在Cluster中运行SecondarySort作业137
6.4.4 利用Secondary Sort回顾Hadoop的关键特性137
6.5 问题定义—使用MapReducer进行连接138
6.5.1 处理多输入：Multiple—Inputs 类138
6.5.2 具备多个输入的Mapper类139
6.5.3 自定义 Partitioner： Carrier—CodeBasedPartioner141
6.5.4 在Reducer中实现连接141
6.5.5 在集群中运行MapReduce连接作业143
6.5.6 探讨与MapReduce相关的Hadoop主要特性144
6.6 问题定义—使用Map—Only 作业进行连接144
6.6.1 基于DistributeCache的解决方案145
6.6.2 在集群中运行Map—Only的连接作业147
6.6.3 总结探讨Map—Only连接时的Hadoop关键特性149
6.7 在MR作业中保存结果到多输出文件149
6.8 使用计数器收集统计数据151
6.9 本章小结153
第7章 Hadoop输入／输出155
7.1 压缩方式155
7.1.1 压缩内容的选择156
7.1.2 各种压缩方式157
7.1.3 配置压缩方式158
7.2 Hadoop的I／O处理过程内部159
7.2.1 Inputformat159
7.2.2 OutputFormat161
7.2.3 自定义OutputFormat：将文本转换成XML161
7.2.4 自定义 InputFormat：使用自定义的XML文件165
7.3 Hadoop文件173
7.3.1 SequenceFile173
7.3.2 MapFiles178
7.3.3 Avro Files180
7.4 本章小结185
第8章 测试Hadoop程序186
8.1 回顾一下单词统计的程序186
8.2 MRUnit概述188
8.2.1 安装MRUnit188
8.2.2 MRUnit 核心类188
8.2.3 编写一个MRUnit测试用例189
8.2.4 测试计数器191
8.2.5 MRUnit的特性194
8.2.6 MRUnit的局限性194
8.3 用LocalJobRunner测试195
8.3.1 setUp（ ）方法196
8.3.2 LocalJobRunner的局限性197
8.4 用MiniMRCluster测试198
8.4.1 配置开发环境198
8.4.2 MiniMRCluster例子199
8.4.3 MiniMRCluster的局限性201
8.5 对访问网络资源的MR作业进行测试202
8.6 本章小结202
第9章Hadoop的监控203
9.1 在Hadoop MapReduce Jobs中写日志消息203
9.2 在Hadoop MapReduce Jobs中查看日志消息206
9.3 在Hadoop 2.x中使用日志管理208
9.3.1 Hadoop 2.x中的日志存储208
9.3.2 日志管理提升210
9.3.3 使用基于Web的界面查看日志210
9.3.4 命令行界面211
9.3.5 日志的保存211
9.4 Hadoop集群性能监控211
9.5 使用YARN REST API212
9.6 使用供应商工具管理Hadoop集群213
9.7 本章小结214
第10章使用Hadoop构建数据仓库215
10.1 Apache Hive215
10.1.1 安装Hive216
10.1.2 Hive的架构217
10.1.3 元数据存储217
10.1.4 HiveQL编译基础217
10.1.5 Hive使用的概念218
10.1.6 HiveQL编译细节222
10.1.7 数据定义语言226
10.1.8 数据操作语言226
10.1.9 扩展接口227
10.1.10 Hive脚本229
10.1.11 性能表现229
10.1.12 整合MapReduce230
10.1.13 创建分区230
10.1.14 用户定义函数232
10.2 Impala234
10.2.1 Impala架构234
10.2.2 Impala特性235
10.2.3 Impala的局限235
10.3 Shark235
10.4 本章小结237
第11章使用Pig进行数据处理238
11.1 Pig简介238
11.2 运行Pig240
11.2.1 在Grunt Shell中执行241
11.2.2 执行Pig脚本241
11.2.3 嵌入式Java程序242
11.3 Pig Latin243
11.3.1 Pig脚本中的注释243
11.3.2 Pig语句的执行243
11.3.3 Pig命令244
11.4 UDF249
11.4.1 Mapper中的Eval函数调用249
11.4.2 Reducer中的Eval函数调用250
11.4.3 编写并使用自定义Filter—Func256
11.5 Pig与Hive对比258
11.6 Crunch API259
11.6.1 Crunch与Pig的区别259
11.6.2 Crunch管道的例子260
11.7 本章小结265
第12章HCatalog和企业级Hadoop266
12.1 HCataolg和企业级数据仓库用户266
12.2 HCatalog技术背景简介 267
12.2.1 HCatalog命令行接口269
12.2.2 WebHCat269
12.2.3 HCatalog的MapReduce接口270
12.2.4 HCatalog的Pig接口273
12.2.5 HCatalog通知接口274
12.3 HCatalog的安全和认证机制274
12.4 完整的解决方案275
12.5 本章小结275
第13章使用Hadoop分析日志277
13.1 日志文件分析应用277
13.1.1 网络分析277
13.1.2 安全规范与法务278
13.1.3 监控和报警279
13.1.4 物联网279
13.2 分析步骤280
13.2.1 载入280
13.2.2 提取280
13.2.3 可视化281
13.3 Apache Flume281
13.4 Netflix Suro283
13.5 云解决方案285
13.6 本章小结285
第14章使用HBase构建实时系统286
14.1 HBase是什么286
14.2 典型的HBase用例场景287
14.3 HBase数据模型288
14.3.1 HBase逻辑视图和客户端视图288
14.3.2 HBase与RDBMS的区别289
14.3.3 HBase表290
14.3.4 HBase单元格290
14.3.5 HBase列簇290
14.4 HBase命令和API291
14.4.1 获取命令列表：帮助命令291
14.4.2 创建表：create命令292
14.4.3 向表中加入行：put命令293
14.4.4 从表中检索行：get命令293
14.4.5 读取多行：scan命令293
14.4.6 统计表中的行数：count命令293
14.4.7 删除行：delete命令294
14.4.8 清空表：truncate命令294
14.4.9 删除表：drop命令294
14.4.10 更换表：alter命令294
14.5 HBase架构295
14.5.1 HBase组件295
14.5.2 HBase中的压缩与分区302
14.5.3 压缩303
14.6 HBase配置概览304
14.7 HBase应用程序设计305
14.7.1 长表vs宽表vs窄表305
14.7.2 行键设计306
14.8 使用Java API操作HBase307
14.8.1 一切都是字节307
14.8.2 创建HBase表307
14.8.3 使用HBaseAdmin类管理HBase308
14.8.4 使用Java API访问数据308
14.9 HBase与MapReduce集成312
14.9.1 使用MapReduce任务读取HBase表312
14.9.2 HBase和MapReduce集群315
14.10 本章小结316
第15章Hadoop与数据科学317
15.1 Hadoop中的数据科学方法318
15.2 Apache Hama318
15.2.1 整体同步并行计算模型318
15.2.2 Hama Hello World！319
15.2.3 蒙特卡洛方法321
15.2.4 K—Means聚类324
15.3 Apache Spark327
15.3.1 弹性分布式数据集（RDD）327
15.3.2 Spark与蒙特卡洛算法328
15.3.3 Spark与KMeans聚类330
15.4 RHadoop332
15.5 本章小结333
第16章Hadoop与云计算334
16.1 经济性334
16.1.1 自有集群335
16.1.2 基于云平台的集群335
16.1.3 弹性336
16.1.4 按需付费336
16.1.5 竞价336
16.1.6 混合集群336
16.2 后勤保障337
16.2.1 导入／导出337
16.2.2 数据保存337
16.3 安全性337
16.4 云端应用模型338
16.5 云服务商339
16.5.1 亚马逊网络服务（AWS）339
16.5.2 谷歌云平台341
16.5.3 微软Azure342
16.5.4 选择云服务商342
16.6 案例学习： AWS342
16.6.1 EMR343
16.6.2 EC2345
16.7 本章小结348
第17章构建YARN应用程序349
17.1 YARN：通用分布式系统349
17.2 YARN：快速浏览351
17.3 创建YARN应用程序353
17.4 DownloadService.java类354
17.5 Client.java类356
17.5.1 从客户端启动应用管理器的步骤356
17.5.2 创建YarnClient357
17.5.3 配置应用程序357
17.5.4 启动应用管理器360
17.5.5 监控应用360
17.6 ApplicationMaster.java362
17.6.1 启动工作任务的步骤363
17.6.2 初始化应用管理器协议和容器管理协议364
17.6.3 在资源管理器中注册应用管理器364
17.6.4 配置容器参数364
17.6.5 向资源管理器请求容器364
17.6.6 在任务节点上启动容器364
17.6.7 等待容器结束工作任务365
17.6.8 在资源管理器中注销应用管理器365
17.7 运行应用管理器367
17.7.1 在非托管模式中启动应用管理器367
17.7.2 在托管模式中启动应用管理器367
17.8 本章小结367
附录Ａ安装Hadoop369
附录B使用Maven和Eclipse378
附录CApache Ambari383