/**
 * <PRE>
 * 编码工具（字符集转码、加/解压、加/解密）
 *
 *
 HTTPS过程建议阅读网站：
 https://www.kuacg.com/22672.html
 https://blog.csdn.net/wenxingchen/article/details/81319905
 https://www.jianshu.com/p/9db57e761255

 https流程总结：
 需要第三方验证是因为保证目标网站的公钥安全分发
 数字签名的作用是：虽然中间人攻击不能修改内容后使用私钥重新加密，但是中间人可能直接对加密后的内容进行修改，这样客户端拿到的报文解密后不知道是不是正确的，
 只有再加多数字签名进行内容验证，因为中间人很难对两个加密后的内容的修改是能对应上的


 客户端先跟第三方CA认证机构通信，获取目标网站的公钥，流程如下：

 1、客户端请求证书，第三方机构使用第三方机构的私钥对目标网站的证书（里面包含公钥）进行加密，同时对原内容生成消息摘要，对消息摘要使用私钥加密变成数字签名，发送给客户端，这整个过程包括了两次加密，一次消息摘要，中间人攻击时，即使修改了内容，但是肯定不能对应地修改消息摘要，或者修改了消息摘要，肯定不能对应地修改内容；
 2、客户端对拿到加密后的内容，使用预先安装的第三方机构的公钥对内容解密，并进行签名校验，如果校验成功说明第三方发过来的加密内容合法，解密拿到目标网站的证书（里面包含公钥）
 3、客户端创建一个对称加密的秘钥，用公钥加密对称秘钥传输给目标网站，因为公钥加密的内容只能用私钥解密，所以肯定只有目标网站能解密
 4、目标网站拿到客户端的报文，用私钥解密出来对称加密的秘钥
 5、此时完成了客户端与目标网站的公钥分发和对称秘钥分发，后面的传输就是可以使用对称秘钥进行加密传输和解密使用

 对称加密算法：AES、DES   只有一个秘钥，加解密都用它
 非对称加密算法：RSA   密码对的方式：公钥加密的私钥才能解，私钥加密的公钥才能解
 数字签名摘要算法：SHA、MD5  生成hash散列值

 因为数字签名

 出现一个问题：虽然别人不知道私钥是什么，拿不到你原始传输的数据，但是可以拿到加密后的数据，他们可以改掉某部分的数据再发送给服务器，这样服务器拿到的数据就不是完整的了。
 3y女朋友给3y发了一条信息”3y我喜欢你“，然后用3y给的公钥加密，发给3y了。此时不怀好意的人截取到这条加密的信息，他破解不了原信息。但是他可以修改加密后的数据再传给3y。可能3y拿到收到的数据就是”3y你今晚跪键盘吧“
 拿到的数据可能被篡改了，我们可以使用数字签名来解决被篡改的问题。数字签名其实也可以看做是非对称加密的手段一种，具体是这样的：得到原信息hash值，用私钥对hash值加密，另一端用公钥解密，最后比对hash值是否变了。如果变了就说明被篡改了。(一端用私钥加密，另一端用公钥解密，也确保了来源)
 目前现在：好像使用了数字签名就万无一失了，其实还有问题。我们使用非对称加密的时候，是使用公钥进行加密的。如果公钥被伪造了，后面的数字签名其实就毫无意义了。讲到底：还是可能会被中间人攻击~此时我们就有了CA认证机构来确认公钥的真实性！

 数字签名的主要方式是：报文的发送方从报文文本中生成一个散列值（或报文摘要），发送方用自己的私有密钥对这个散列值进行加密来形成发送方的数字签名，然后这个数字签名将作为报文的附件和报文一起发送给报文的接收方，报文的接收方首先从接收到的原始报文中计算出散列值（或报文摘要），接着再用发送方的公开密钥来对报文附加的数字签名进行解密，如果两个散列值相同，那么接收方就能确认该数字签名是发送方的。




 简单来说，数字签名（digital signature）是公钥密码的逆应用：用私钥加密消息，用公钥解密消息。
 用私钥加密的消息称为签名，只有拥有私钥的用户可以生成签名。
 用公钥解密签名这一步称为验证签名，所有用户都可以验证签名(因为公钥是公开的)
 一旦签名验证成功，根据公私钥数学上的对应关系，就可以知道该消息是唯一拥有私钥的用户发送的，而不是随便一个用户发送的。
 由于私钥是唯一的，因此数字签名可以保证发送者事后不能抵赖对报文的签名。由此，消息的接收者可以通过数字签名，使第三方确信签名人的身份及发出消息的事实。当双方就消息发出与否及其内容出现争论时，数字签名就可成为一个有力的证据。
 生成签名
 一般来说，不直接对消息进行签名，而是对消息的哈希值进行签名，步骤如下。
 对消息进行哈希计算，得到哈希值
 利用私钥对哈希值进行加密，生成签名
 将签名附加在消息后面，一起发送过去
 验证签名
 收到消息后，提取消息中的签名
 用公钥对签名进行解密，得到哈希值1。
 对消息中的正文进行哈希计算，得到哈希值2。
 比较哈希值1和哈希值2，如果相同，则验证成功。
 3.证书
 证书实际上就是对公钥进行数字签名，它是对公钥合法性提供证明的技术。
 考虑这样一种场景：我们对签名进行验证时，需要用到公钥。如果公钥也是伪造的，那怎么办？如果公钥是假的，验证数字签名那就无从谈起，根本不可能从数字签名确定对方的合法性。
 这时候证书就派上用场了。
 证书一般包含：公钥（记住证书中是带有公钥的），公钥的数字签名，公钥拥有者的信息
 若证书验证成功，这表示该公钥是合法，可信的。
 接下来又有问题了：验证证书中的数字签名需要另一个公钥，那么这个公钥的合法性又该如何保证？该问题可以无限循环下去，岂不是到不了头了？这已经是个社会学问题了。我们为什么把钱存进银行？因为我们相信银行，它是一个可信的机构（虽然也有破产的风险）。跟银行一样，我们需要一个可信的机构来颁发证书和提供公钥，只要是它提供的公钥，我们就相信是合法的。
 这种机构称为认证机构(Certification Authority， CA)。CA就是能够认定”公钥确实属于此人”，并能生成公钥的数字签名的组织或机构。CA有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的组织。
 如何生成证书？
 服务器将公钥A给CA（公钥是服务器的）
 CA用自己的私钥B给公钥A加密，生成数字签名A
 CA把公钥A，数字签名A，附加一些服务器信息整合在一起，生成证书，发回给服务器。
 注：私钥B是用于加密公钥A的，私钥B和公钥A并不是配对的。
 如何验证证书？
 客户端得到证书
 客户端得到证书的公钥B（通过CA或其它途径）
 客户端用公钥B对证书中的数字签名解密，得到哈希值
 客户端对公钥进行哈希值计算
 两个哈希值对比，如果相同，则证书合法。
 注：公钥B和上述的私钥B是配对的，分别用于对证书的验证（解密）和生成（加密）。
 证书作废
 当用户私钥丢失、被盗时，认证机构需要对证书进行作废(revoke)。要作废证书，认证机构需要制作一张证书作废清单(Certificate Revocation List)，简称CRL
 假设我们有Bob的证书，该证书有合法的认证机构签名，而且在有效期内，但仅凭这些还不能说明该证书一定有效，还需要查询认证机构最新的CRL，并确认该证书是否有效。
 使用场景
 下面用两个使用场景来帮助大家理解证书的作用。
 客户端在发送或接收消息之前，要验证服务器的合法性(这个服务器是真实的服务器，还是伪造者，我们不知道)
 场景1
 服务器生成公钥和私钥密码对
 服务器把公钥给CA。CA生成证书，发送给客户端
 客户端验证证书，取得公钥：此刻证明公钥是合法的
 客户端用公钥加密消息，发送给服务器
 服务器用私钥解密消息（消息加密发送，具有保密性）
 场景2
 服务器生成公钥和私钥密码对
 服务器生成消息，用私钥对消息进行数字签名
 服务器把公钥给CA。CA生成证书
 服务器将消息，数字签名，证书一起发送给客户端
 客户端验证证书，取得公钥：此刻证明公钥是合法的
 客户端用公钥验证数字签名，检查消息的完整性和服务器的合法性

 * </PRE>
 *
 * @author: latico
 * @date: 2019-02-06 22:51
 * @version: 1.0
 */
package com.latico.commons.common.util.codec;