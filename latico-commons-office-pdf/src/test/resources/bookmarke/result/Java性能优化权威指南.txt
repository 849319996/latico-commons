目录	24
第1章　策略、方法和方法论	15
	1.1　性能问题的现状	15
	1.2　性能分析的两种方法：自顶向下和自底向上	18
		1.2.1　自顶向下	18
		1.2.2　自底向上	19
	1.3　选择正确的平台并评估系统性能	19
		1.3.1　选择正确的CPU架构	20
		1.3.2　评估系统性能	21
	1.4　参考资料	21
第2章　操作系统性能监控	22
	2.1　定义	22
	2.2　CPU使用率	23
		2.2.1　监控CPU使用率：Windows	23
		2.2.2　监控CPU使用率：Windows typeperf	26
		2.2.3　监控CPU使用率：Linux	27
		2.2.4　监控CPU使用率：Solaris	28
		2.2.5　命令行监控CPU使用率：Linux和Solaris	30
	2.3　CPU调度程序运行队列	33
		2.3.1　监控CPU调度程序运行队列：Windows	33
		2.3.2　监控CPU调度程序运行队列：Solaris	35
		2.3.3　监控CPU调度程序运行队列：Linux	35
	2.4　内存使用率	36
		2.4.1　监控内存利用率：Windows	36
		2.4.2　监控内存使用率：Solaris	37
		2.4.3　监控内存使用率：Linux	38
		2.4.4　监控锁竞争：Solaris	39
		2.4.5　监控锁竞争：Linux	40
		2.4.6　监控锁竞争：Windows	41
		2.4.7　隔离竞争锁	41
		2.4.8　监控抢占式上下文切换	41
		2.4.9　监控线程迁移	42
	2.5　网络I/O使用率	42
		2.5.1　监控网络I/O使用率：Solaris	43
		2.5.2　监控网络I/O使用率：Linux	44
		2.5.3　监控网络I/O使用率：Windows	44
		2.5.4　应用性能改进的考虑	45
	2.6　磁盘I/O使用率	45
	2.7　其他命令行工具	48
	2.8　监控CPU使用率：SPARC T系列系统	49
	2.9　参考资料	50
第3章　JVM概览	52
	3.1　HotSpot VM的基本架构	52
	3.2　HotSpot VM运行时	54
		3.2.1　命令行选项	54
		3.2.2　VM生命周期	55
		3.2.3　VM类加载	58
		3.2.4　字节码验证	60
		3.2.5　类数据共享	61
		3.2.6　解释器	62
		3.2.7　异常处理	63
		3.2.8　同步	64
		3.2.9　线程管理	65
		3.2.10　C++堆管理	67
		3.2.11　Java本地接口	68
		3.2.12　VM致命错误处理	69
	3.3　HotSpot VM垃圾收集器	70
		3.3.1　分代垃圾收集	70
		3.3.2　新生代	72
		3.3.3　快速内存分配	74
		3.3.4　垃圾收集器	74
		3.3.5　Serial收集器	75
		3.3.6　Parallel收集器：吞吐量为先！	76
		3.3.7　Mostly-Concurrent收集器：低延迟为先！	76
		3.3.8　Garbage-First收集器：CMS替代者	78
		3.3.9　垃圾收集器比较	78
		3.3.10　应用程序对垃圾收集器的影响	79
		3.3.11　简单回顾收集器历史	79
	3.4　HotSpot VM JIT编译器	79
		3.4.1　类型继承关系分析	81
		3.4.2　编译策略	81
		3.4.3　逆优化	82
		3.4.4　Client JIT编译器概览	83
		3.4.5　Server JIT编译器概览	83
		3.4.6　静态单赋值——程序依赖图	83
		3.4.7　未来增强展望	85
	3.5　HotSpot VM自适应调优	85
		3.5.1　Java 1.4.2的默认值	85
		3.5.2　Java 5自动优化的默认值	85
		3.5.3　Java 6 Update 18更新后的默认优化值	87
		3.5.4　自适应Java堆调整	88
		3.5.5　超越自动优化	89
	3.6　参考资料	89
第4章　JVM性能监控	91
	4.1　定义	91
	4.2　垃圾收集	92
		4.2.1　重要的垃圾收集数据	92
		4.2.2　垃圾收集报告	92
		4.2.3　垃圾收集数据的离线分析	100
		4.2.4　图形化工具	103
	4.3　JIT编译器	117
	4.4　类加载	118
	4.5　Java应用监控	120
	4.6　参考资料	123
第5章　Java应用性能分析	124
	5.1　术语	125
		5.1.1　通用性能分析术语	125
		5.1.2　Oracle Solaris Studio Performance Analyzer术语	126
		5.1.3　NetBeans Profiler术语	126
	5.2　Oracle Solaris Studio Performance Analyzer	126
		5.2.1　支持平台	127
		5.2.2　下载/安装Oracle Solaris Studio Performance Analyzer	128
		5.2.3　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据	128
		5.2.4　查看性能数据	132
		5.2.5　数据表示	139
		5.2.6　过滤性能数据	142
		5.2.7　命令行工具er_print	143
	5.3　NetBeans Profiler	149
		5.3.1　支持平台	150
		5.3.2　下载安装NetBeans Profiler	150
		5.3.3　开始方法分析会话	151
		5.3.4　Controls子面板	157
		5.3.5　Status子面板	157
		5.3.6　Profiling Results子面板	157
		5.3.7　Saved Snapshots子面板	158
		5.3.8　View子面板	158
		5.3.9　Basic Telemetry子面板	158
		5.3.10　查看动态结果	159
		5.3.11　对结果进行快照	159
		5.3.12　启动内存分析会话	160
		5.3.13　查看实时结果	162
		5.3.14　对结果进行快照	164
		5.3.15　定位内存泄漏	164
		5.3.16　分析堆转储	165
	5.4　参考资料	166
第6章　Java应用性能分析技巧	167
	6.1　性能优化机会	167
	6.2　系统或内核态CPU使用	168
	6.3　锁竞争	175
	6.4　Volatile的使用	185
	6.5　调整数据结构的大小	186
		6.5.1　StringBuilder或StringBuffer大小的调整	186
		6.5.2　Java Collection类大小调整	189
	6.6　增加并行性	193
	6.7　过高的CPU使用率	195
	6.8　其他有用的分析提示	196
	6.9　参考资料	198
第7章　JVM性能调优入门	199
	7.1　方法	199
		7.1.1　假设条件	201
		7.1.2　测试基础设施需求	202
	7.2　应用程序的系统需求	202
		7.2.1　可用性	202
		7.2.2　可管理性	202
		7.2.3　吞吐量	203
		7.2.4　延迟及响应性	203
		7.2.5　内存占用	203
		7.2.6　启动时间	203
	7.3　对系统需求分级	204
	7.4　选择JVM部署模式	204
		7.4.1　单JVM部署模式	204
		7.4.2　多JVM部署模式	204
		7.4.3　通用建议	205
	7.5　选择JVM运行模式	205
		7.5.1　Client模式或Server模式	205
		7.5.2　32位/64位 JVM	206
		7.5.3　垃圾收集器	206
	7.6　垃圾收集调优基础	207
		7.6.1　性能属性	207
		7.6.2　原则	207
		7.6.3　命令行选项及GC日志	208
	7.7　确定内存占用	211
		7.7.1　约束	211
		7.7.2　HotSpot VM堆的布局	211
		7.7.3　堆大小调优着眼点	214
		7.7.4　计算活跃数据大小	215
		7.7.5　初始堆空间大小配置	216
		7.7.6　其他考量因素	217
	7.8　调优延迟/响应性	218
		7.8.1　输入	219
		7.8.2　优化新生代的大小	219
		7.8.3　优化老年代的大小	221
		7.8.4　为CMS调优延迟	224
		7.8.5　Survivor空间介绍	226
		7.8.6　解析晋升阈值	228
		7.8.7　监控晋升阈值	229
		7.8.8　调整Survivor空间的容量	230
		7.8.9　显式的垃圾收集	236
		7.8.10　并发永久代垃圾收集	237
		7.8.11　调优CMS停顿时间	238
		7.8.12　下一步	239
	7.9　应用程序吞吐量调优	239
		7.9.1　CMS吞吐量调优	239
		7.9.2　Throughput收集器调优	240
		7.9.3　Survivor空间调优	242
		7.9.4　调优并行垃圾收集线程	245
		7.9.5　在NUMA系统上部署	245
		7.9.6　下一步	246
	7.10　极端示例	246
	7.11　其他性能命令行选项	246
		7.11.1　实验性（最近最大）优化	246
		7.11.2　逃逸分析	247
		7.11.3　偏向锁	247
		7.11.4　大页面支持	248
	7.12　参考资料	250
第8章　Java应用的基准测试	251
	8.1　基准测试所面临的挑战	251
		8.1.1　基准测试的预热阶段	252
		8.1.2　垃圾收集	254
		8.1.3　使用Java Time接口	254
		8.1.4　剔除无效代码	255
		8.1.5　内联	261
		8.1.6　逆优化	265
		8.1.7　创建微基准测试的注意事项	270
	8.2　实验设计	271
	8.3　使用统计方法	272
		8.3.1　计算均值	272
		8.3.2　计算标准差	272
		8.3.3　计算置信区间	273
		8.3.4　使用假设测试	274
		8.3.5　使用统计方法的注意事项	276
	8.4　参考文献	277
	8.5　参考资料	277
第9章　多层应用的基准测试	278
	9.1　基准测试难题	278
	9.2　企业级应用基准测试的考量	280
		9.2.1　定义被测系统	280
		9.2.2　制定微基准测试	280
		9.2.3　定义用户交互模型	281
		9.2.4　定义性能指标	284
		9.2.5　扩展基准测试	287
		9.2.6　用利特尔法则验证	288
		9.2.7　思考时间	289
		9.2.8　扩展性分析	292
		9.2.9　运行基准测试	292
	9.3　应用服务器监控	295
		9.3.1　GlassFish监控	295
		9.3.2　监控子系统	300
		9.3.3　Solaris	301
		9.3.4　Linux	302
		9.3.5　Windows	302
		9.3.6　外部系统的性能	303
		9.3.7　磁盘I/O	306
		9.3.8　监控和调优资源池	307
	9.4　企业级应用性能分析	308
	9.5　参考资料	309
第10章　Web应用的性能调优	311
	10.1　Web应用的基准测试	312
	10.2　Web容器的组件	312
		10.2.1　HTTP连接器	313
		10.2.2　Servlet引擎	314
	10.3　Web容器的监控和性能调优	314
		10.3.1　容器的开发和生产模式	314
		10.3.2　安全管理器	315
		10.3.3　JVM调优	315
		10.3.4　HTTP服务和Web容器	317
		10.3.5　HTTP监听器	317
	10.4　最佳实践	329
		10.4.1　Servlet和JSP最佳实践	329
		10.4.2　内容缓存	338
		10.4.3　会话持久化	342
		10.4.4　HTTP服务器文件缓存	343
	10.5　参考资料	347
第11章　Web Service的性能	348
	11.1　XML的性能	348
		11.1.1　XML处理的生命周期	349
		11.1.2　解析/解编组	349
		11.1.3　访问	352
		11.1.4　修改	352
		11.1.5　序列化/编组	353
	11.2　验证	353
	11.3　解析外部实体	355
	11.4　XML文档的局部处理	357
	11.5　选择合适的API	360
	11.6　JAX-WS参考实现栈	363
	11.7　Web Service基准测试	364
	11.8　影响Web Service性能的因素	367
		11.8.1　消息大小的影响	367
		11.8.2　不同Schema类型的性能特征	369
		11.8.3　终端服务器的实现	372
		11.8.4　处理程序的性能	373
	11.9　最佳性能实践	375
		11.9.1　二进制负载的处理	375
		11.9.2　处理XML文档	379
		11.9.3　使用MTOM发送XML文档	379
		11.9.4　使用Provider接口	382
		11.9.5　快速信息集	384
		11.9.6　HTTP压缩	386
		11.9.7　Web Service客户端的性能	387
	11.10　参考资料	388
第12章　Java持久化及Enterprise Java Bean的性能	389
	12.1　EJB编程模型	390
	12.2　Java持久化API及其参考实现	390
	12.3　监控及调优EJB容器	393
		12.3.1　线程池	394
		12.3.2　Bean池和缓存	396
		12.3.3　EclipseLink会话缓存	399
	12.4　事务隔离级	400
	12.5　Enterprise Java Bean的最佳实践	401
		12.5.1　简要说明使用的EJB基准测试	401
		12.5.2　EJB 2.1	402
		12.5.3　EJB 3.0	414
	12.6　Java持久化最佳实践	417
		12.6.1　JPA查询语言中的查询	417
		12.6.2　查询结果缓存	419
		12.6.3　FetchType	420
		12.6.4　连接池	422
		12.6.5　批量更新	423
		12.6.6　选择正确的数据库锁策略	425
		12.6.7　不带事务的读取	425
		12.6.8　继承	425
	12.7　参考资料	426
附录A 　重要的HotSpot VM选项	427
附录B 　性能分析技巧示例源代码	443
	B.1　锁竞争实现1	443
	B.2　锁竞争实现2	453
	B.3　锁竞争实现3	463
	B.4　锁竞争实现4	473
	B.5　锁竞争实现5	483
	B.6　调整容量变化1	495
	B.7　调整容量变化2	506
	B.8　增加并发性的单线程实现	518
	B.9　增加并发性的多线程实现	528
