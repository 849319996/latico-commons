封面	1
数字版权声明	2
作译者介绍	3
扉页	4
版权页	5
版权声明	6
献词	7
序言	8
致谢	10
关于本书	12
关于封面图	15
目录	16
第一部分　基础知识	22
第1章　为什么要关心Java 8	23
	1.1　Java怎么还在变	25
		1.1.1　Java在编程语言生态系统中的位置	25
		1.1.2　流处理	27
		1.1.3　用行为参数化把代码传递给方法	28
		1.1.4　并行与共享的可变数据	28
		1.1.5　Java需要演变	29
	1.2　Java中的函数	29
		1.2.1　方法和Lambda作为一等公民	30
		1.2.2　传递代码：一个例子	32
		1.2.3　从传递方法到Lambda	33
	1.3　流	34
	1.4　默认方法	38
	1.5　来自函数式编程的其他好思想	39
	1.6　小结	40
第2章　通过行为参数化传递代码	41
	2.1　应对不断变化的需求	42
		2.1.1　初试牛刀：筛选绿苹果	42
		2.1.2　再展身手：把颜色作为参数	42
		2.1.3　第三次尝试：对你能想到的每个属性做筛选	43
	2.2　行为参数化	44
	2.3　对付啰嗦	48
		2.3.1　匿名类	49
		2.3.2　第五次尝试：使用匿名类	49
		2.3.3　第六次尝试：使用Lambda表达式	51
		2.3.4　第七次尝试：将List类型抽象化	52
	2.4　真实的例子	52
		2.4.1　用Comparator来排序	52
		2.4.2　用Runnable执行代码块	53
		2.4.3　GUI事件处理	53
	2.5　小结	54
第3章　Lambda 表达式	55
	3.1　Lambda管中窥豹	56
	3.2　在哪里以及如何使用Lambda	58
		3.2.1　函数式接口	58
		3.2.2　函数描述符	60
	3.3　把Lambda付诸实践：环绕执行模式	62
		3.3.1　第1步：记得行为参数化	62
		3.3.2　第2步：使用函数式接口来传递行为	63
		3.3.3　第3步：执行一个行为	63
		3.3.4　第4步：传递Lambda	63
	3.4　使用函数式接口	64
		3.4.1　Predicate	65
		3.4.2　Consumer	65
		3.4.3　Function	66
	3.5　类型检查、类型推断以及限制	70
		3.5.1　类型检查	70
		3.5.2　同样的Lambda，不同的函数式接口	71
		3.5.3　类型推断	72
		3.5.4　使用局部变量	73
	3.6　方法引用	74
		3.6.1　管中窥豹	74
		3.6.2　构造函数引用	76
	3.7　Lambda和方法引用实战	78
		3.7.1　第1步：传递代码	79
		3.7.2　第2步：使用匿名类	79
		3.7.3　第3步：使用Lambda表达式	79
		3.7.4　第4步：使用方法引用	80
	3.8　复合Lambda表达式的有用方法	80
		3.8.1　比较器复合	81
		3.8.2　谓词复合	81
		3.8.3　函数复合	82
	3.9　数学中的类似思想	83
		3.9.1　积分	83
		3.9.2　与Java 8的Lambda联系起来	84
	3.10　小结	85
第二部分　函数式数据处理	88
第4章　引入流	89
	4.1　流是什么	89
	4.2　流简介	93
	4.3　流与集合	95
		4.3.1　只能遍历一次	96
		4.3.2　外部迭代与内部迭代	97
	4.4　流操作	99
		4.4.1　中间操作	99
		4.4.2　终端操作	100
		4.4.3　使用流	101
	4.5　小结	102
第5章　使用流	103
	5.1　筛选和切片	104
		5.1.1　用谓词筛选	104
		5.1.2　筛选各异的元素	104
		5.1.3　截短流	105
		5.1.4　跳过元素	106
	5.2　映射	107
		5.2.1　对流中每一个元素应用函数	107
		5.2.2　流的扁平化	108
	5.3　查找和匹配	111
		5.3.1　检查谓词是否至少匹配一个元素	111
		5.3.2　检查谓词是否匹配所有元素	111
		5.3.3　查找元素	112
		5.3.4　查找第一个元素	113
	5.4　归约	113
		5.4.1　元素求和	114
		5.4.2　最大值和最小值	115
	5.5　付诸实践	118
		5.5.1　领域：交易员和交易	119
		5.5.2　解答	120
	5.6　数值流	122
		5.6.1　原始类型流特化	122
		5.6.2　数值范围	123
		5.6.3　数值流应用：勾股数	124
	5.7　构建流	126
		5.7.1　由值创建流	127
		5.7.2　由数组创建流	127
		5.7.3　由文件生成流	127
		5.7.4　由函数生成流：创建无限流	128
	5.8　小结	131
第6章　用流收集数据	132
	6.1　收集器简介	133
		6.1.1　收集器用作高级归约	133
		6.1.2　预定义收集器	134
	6.2　归约和汇总	135
		6.2.1　查找流中的最大值和最小值	135
		6.2.2　汇总	136
		6.2.3　连接字符串	137
		6.2.4　广义的归约汇总	138
	6.3　分组	141
		6.3.1　多级分组	142
		6.3.2　按子组收集数据	143
	6.4　分区	147
		6.4.1　分区的优势	147
		6.4.2　将数字按质数和非质数分区	149
	6.5　收集器接口	150
		6.5.1　理解Collector接口声明的方法	151
		6.5.2　全部融合到一起	155
	6.6　开发你自己的收集器以获得更好的性能	156
		6.6.1　仅用质数做除数	157
		6.6.2　比较收集器的性能	160
	6.7　小结	161
第7章　并行数据处理与性能	162
	7.1　并行流	162
		7.1.1　将顺序流转换为并行流	163
		7.1.2　测量流性能	165
		7.1.3　正确使用并行流	168
		7.1.4　高效使用并行流	169
	7.2　分支/合并框架	170
		7.2.1　使用RecursiveTask	170
		7.2.2　使用分支/合并框架的最佳做法	174
		7.2.3　工作窃取	175
	7.3　Spliterator	176
		7.3.1　拆分过程	176
		7.3.2　实现你自己的Spliterator	178
	7.4　小结	183
第三部分　高效Java 8编程	184
第8章　重构、测试和调试	185
	8.1　为改善可读性和灵活性重构代码	185
		8.1.1　改善代码的可读性	186
		8.1.2　从匿名类到Lambda表达式的转换	186
		8.1.3　从Lambda表达式到方法引用的转换	187
		8.1.4　从命令式的数据处理切换到Stream	188
		8.1.5　增加代码的灵活性	189
	8.2　使用Lambda重构面向对象的设计模式	191
		8.2.1　策略模式	192
		8.2.2　模板方法	193
		8.2.3　观察者模式	194
		8.2.4　责任链模式	196
		8.2.5　工厂模式	198
	8.3　测试Lambda表达式	199
		8.3.1　测试可见Lambda函数的行为	200
		8.3.2　测试使用Lambda的方法的行为	200
		8.3.3　将复杂的Lambda表达式分到不同的方法	201
		8.3.4　高阶函数的测试	201
	8.4　调试	202
		8.4.1　查看栈跟踪	202
		8.4.2　使用日志调试	204
	8.5　小结	205
第9章　默认方法	206
	9.1　不断演进的API	208
		9.1.1　初始版本的API	209
		9.1.2　第二版API	209
	9.2　概述默认方法	211
	9.3　默认方法的使用模式	213
		9.3.1　可选方法	213
		9.3.2　行为的多继承	213
	9.4　解决冲突的规则	217
		9.4.1　解决问题的三条规则	217
		9.4.2　选择提供了最具体实现的默认方法的接口	218
		9.4.3　冲突及如何显式地消除歧义	219
		9.4.4　菱形继承问题	221
	9.5　小结	222
第10章　用Optional取代null	223
	10.1　如何为缺失的值建模	224
		10.1.1　采用防御式检查减少NullPointerException	224
		10.1.2　null带来的种种问题	225
		10.1.3　其他语言中null的替代品	226
	10.2　Optional类入门	227
	10.3　应用Optional的几种模式	228
		10.3.1　创建Optional对象	229
		10.3.2　使用map从Optional对象中提取和转换值	229
		10.3.3　使用flatMap链接Optional对象	230
		10.3.4　默认行为及解引用Optional对象	234
		10.3.5　两个Optional对象的组合	234
		10.3.6　使用filter剔除特定的值	235
	10.4　使用Optional的实战示例	237
		10.4.1　用Optional封装可能为null的值	237
		10.4.2　异常与Optional的对比	238
		10.4.3　把所有内容整合起来	239
	10.5　小结	240
第11章　CompletableFuture：组合式 异步编程	241
	11.1　Future接口	243
		11.1.1　Future接口的局限性	244
		11.1.2　使用CompletableFuture构建异步应用	244
	11.2　实现异步API	245
		11.2.1　将同步方法转换为异步方法	246
		11.2.2　错误处理	248
	11.3　让你的代码免受阻塞之苦	249
		11.3.1　使用并行流对请求进行并行操作	250
		11.3.2　使用CompletableFuture发起异步请求	251
		11.3.3　寻找更好的方案	253
		11.3.4　使用定制的执行器	254
	11.4　对多个异步任务进行流水线操作	255
		11.4.1　实现折扣服务	256
		11.4.2　使用Discount服务	257
		11.4.3　构造同步和异步操作	258
		11.4.4　将两个CompletableFuture对象整合起来，无论它们是否存在依赖	260
		11.4.5　对Future和CompletableFuture的回顾	262
	11.5　响应CompletableFuture的completion事件	263
		11.5.1　对最佳价格查询器应用的优化	264
		11.5.2　付诸实践	265
	11.6　小结	266
第12章　新的日期和时间API	267
	12.1　LocalDate、LocalTime、Instant、Duration以及Period	268
		12.1.1　使用LocalDate和LocalTime	268
		12.1.2　合并日期和时间	269
		12.1.3　机器的日期和时间格式	270
		12.1.4　定义Duration或Period	270
	12.2　操纵、解析和格式化日期	272
		12.2.1　使用TemporalAdjuster	274
		12.2.2　打印输出及解析日期时间对象	276
	12.3　处理不同的时区和历法	277
		12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区	278
		12.3.2　使用别的日历系统	279
	12.4　小结	280
第四部分　超越Java 8	282
第13章　函数式的思考	283
	13.1　实现和维护系统	283
		13.1.1　共享的可变数据	284
		13.1.2　声明式编程	285
		13.1.3　为什么要采用函数式编程	286
	13.2　什么是函数式编程	286
		13.2.1　函数式Java编程	287
		13.2.2　引用透明性	289
		13.2.3　面向对象的编程和函数式编程的对比	289
		13.2.4　函数式编程实战	290
	13.3　递归和迭代	292
	13.4　小结	295
第14章　函数式编程的技巧	296
	14.1　无处不在的函数	296
		14.1.1　高阶函数	296
		14.1.2　科里化	298
	14.2　持久化数据结构	299
		14.2.1　破坏式更新和函数式更新的比较	300
		14.2.2　另一个使用Tree的例子	302
		14.2.3　采用函数式的方法	303
	14.3　Stream的延迟计算	304
		14.3.1　自定义的Stream	304
		14.3.2　创建你自己的延迟列表	307
	14.4　模式匹配	311
		14.4.1　访问者设计模式	312
		14.4.2　用模式匹配力挽狂澜	313
	14.5　杂项	316
		14.5.1　缓存或记忆表	316
		14.5.2　“返回同样的对象”意味着什么	317
		14.5.3　结合器	317
	14.6　小结	318
第15章　面向对象和函数式编程的混合： Java 8和Scala的比较	320
	15.1　Scala简介	321
		15.1.1　你好，啤酒	321
		15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option	323
	15.2　函数	327
		15.2.1　Scala中的一等函数	328
		15.2.2　匿名函数和闭包	328
		15.2.3　科里化	330
	15.3　类和trait	331
		15.3.1　更加简洁的Scala类	331
		15.3.2　Scala的trait与Java 8的接口对比	332
	15.4　小结	333
第16章　结论以及Java的未来	334
	16.1　回顾Java 8的语言特性	334
		16.1.1　行为参数化（Lambda以及方法引用）	335
		16.1.2　流	335
		16.1.3　CompletableFuture	336
		16.1.4　Optional	336
		16.1.5　默认方法	337
	16.2　Java的未来	337
		16.2.1　集合	337
		16.2.2　类型系统的改进	338
		16.2.3　模式匹配	339
		16.2.4　更加丰富的泛型形式	340
		16.2.5　对不变性的更深层支持	342
		16.2.6　值类型	343
	16.3　写在最后的话	346
附录A　其他语言特性的更新	347
附录B　类库的更新	351
附录C　如何以并发方式在同一个流上 执行多种操作	359
附录D　Lambda 表达式和JVM字 节码	367
